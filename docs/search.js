window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "ultk", "modulename": "ultk", "kind": "module", "doc": "<h1 id=\"the-unnatural-language-toolkit-ultk\">The Unnatural Language ToolKit (ULTK)</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n\n<p>ULTK is an open-source Python library for computational semantic typology research. ULTK's key features include unifying data structures, algorithms for generating artificial languages, and data analysis tools for related computational experiments.</p>\n\n<p>Read the <a href=\"https://clmbr.shane.st/ultk\">documentation</a>.</p>\n\n<h2 id=\"installing-ultk\">Installing ULTK</h2>\n\n<p>First, set up a virtual environment (e.g. via <a href=\"https://docs.conda.io/en/latest/miniconda.html\">miniconda</a>, <code>conda create -n ultk python=3.11</code>, and <code>conda activate ultk</code>).</p>\n\n<ol>\n<li><p>Download or clone this repository and navigate to the root folder.</p></li>\n<li><p>Install ULTK (We recommend doing this inside a virtual environment)</p>\n\n<p><code>pip install -e .</code></p></li>\n</ol>\n\n<h2 id=\"getting-started\">Getting started</h2>\n\n<ul>\n<li>Check out the <a href=\"https://github.com/CLMBRs/ultk/tree/main/src/examples\">examples</a>, starting with a simple efficient communication analysis of <a href=\"https://github.com/CLMBRs/ultk/tree/main/src/examples/indefinites\">indefinites</a> and <a href=\"https://github.com/CLMBRs/ultk/tree/main/src/examples/modals\">modals</a>.</li>\n<li>For an introduction to efficient communication research, here is a <a href=\"https://www.annualreviews.org/doi/abs/10.1146/annurev-linguistics-011817-045406\">survey paper</a> of the field.</li>\n<li>For an introduction to the RSA framework, see <a href=\"http://www.problang.org/\">this online textbook</a>.</li>\n</ul>\n\n<h2 id=\"modules\">Modules</h2>\n\n<p>There are two modules. The first is <a href=\"https://clmbr.shane.st/ultk/ultk/effcomm.html\">ultk.effcomm</a>, which includes methods for measuring informativity of languages and/or communicative success of Rational Speech Act agents, and for language population sampling and optimization w.r.t Pareto fronts.</p>\n\n<p>The second module is <a href=\"https://clmbr.shane.st/ultk/ultk/language.html\">ultk.language</a>, which contains primitives for constructing semantic spaces, expressions, and languages.  It also has a <code>grammar</code> module which can be used for building expressions in a Language of Thought and measuring complexity in terms of minimum description length, as well as for natural language syntax.</p>\n\n<p>The source code is available on github <a href=\"https://github.com/CLMBRs/ultk\">here</a>.</p>\n\n<h2 id=\"testing\">Testing</h2>\n\n<p>Unit tests are written in <a href=\"https://docs.pytest.org/en/7.3.x/\">pytest</a> and executed via running <code>pytest</code> in the <code>src/tests</code> folder.</p>\n\n<h2 id=\"references\">References</h2>\n\n<p><details>\n<summary>Figures:</summary></p>\n\n<blockquote>\n  <p>Kemp, C. &amp; Regier, T. (2012). Kinship Categories Across Languages Reflect General Communicative Principles. Science. <a href=\"https://www.science.org/doi/10.1126/science.1218811\">https://www.science.org/doi/10.1126/science.1218811</a></p>\n</blockquote>\n\n<blockquote>\n  <p>Zaslavsky, N., Kemp, C., Regier, T., &amp; Tishby, N. (2018). Efficient compression in color naming and its evolution. Proceedings of the National Academy of Sciences, 115(31), 7937\u20137942. <a href=\"https://doi.org/10.1073/pnas.1800521115\">https://doi.org/10.1073/pnas.1800521115</a></p>\n</blockquote>\n\n<blockquote>\n  <p>Deni\u0107, M., Steinert-Threlkeld, S., &amp; Szymanik, J. (2022). Indefinite Pronouns Optimize the Simplicity/Informativeness Trade-Off. Cognitive Science, 46(5), e13142. <a href=\"https://doi.org/10.1111/cogs.13142\">https://doi.org/10.1111/cogs.13142</a></p>\n</blockquote>\n\n<blockquote>\n  <p>Steinert-Threlkeld, S. (2021). Quantifiers in Natural Language: Efficient Communication and Degrees of Semantic Universals. Entropy, 23(10), Article 10. <a href=\"https://doi.org/10.3390/e23101335\">https://doi.org/10.3390/e23101335</a></p>\n</blockquote>\n\n<p></details></p>\n\n<p><details>\n<summary>Links:</summary></p>\n\n<blockquote>\n  <p>Imel, N., &amp; Steinert-Threlkeld, S. (2022). Modal semantic universals optimize the simplicity/informativeness trade-off. Semantics and Linguistic Theory, 1(0), Article 0. <a href=\"https://doi.org/10.3765/salt.v1i0.5346\">https://doi.org/10.3765/salt.v1i0.5346</a></p>\n</blockquote>\n\n<blockquote>\n  <p>Kemp, C., Xu, Y., &amp; Regier, T. (2018). Semantic Typology and Efficient Communication. Annual Review of Linguistics, 4(1), 109\u2013128. <a href=\"https://doi.org/10.1146/annurev-linguistics-011817-045406\">https://doi.org/10.1146/annurev-linguistics-011817-045406</a></p>\n</blockquote>\n\n<p></details></p>\n"}, {"fullname": "ultk.effcomm", "modulename": "ultk.effcomm", "kind": "module", "doc": "<p>Tools for measuring languages for communicative efficiency. </p>\n\n<p>Submodules divide the labor of a computational experiment performing an efficiency analysis of a language into several parts: generating and sampling the space of possible languages, measuring their properties, and determining which languages optimize efficient trade-offs w.r.t these properties.</p>\n\n<p>The <code>ultk.effcomm.agent</code> submodule implements classes for constructing various speakers and listeners of a language. These are unified abstractions from the Rational Speech Act framework.</p>\n\n<p>The <code>ultk.effcomm.analysis</code> submodule contains tools for performing numerical analyses and producing paradigmatic plots of languages in 2D trade-off space.</p>\n\n<p>The <code>ultk.effcomm.informativity</code> submodule implements tools for computing the literal or pragmatic informativity of a language, based on speaker/listener  abstractions described above.</p>\n\n<p>The <code>ultk.effcomm.optimization</code> submodule contains a general implementation of an evolutionary algorithm, which can be used to estimate a Pareto frontier of optimal solutions to an efficiency trade-off. It can also be used as a technique for randomly exploring the space of possible languages.</p>\n\n<p>The <code>ultk.effcomm.sampling</code> submodule implements several methods for generating hypothetically possible languages of a given type, by sampling from a set of possible expressions, or permuting the expression-meaning mapping of an existing language.</p>\n\n<p>The <code>ultk.effcomm.tradeoff</code> submodule contains tools for measuring a pool of languages for various properties, finding which languages are Pareto dominant with respect to two properties, and setting attributes of the language objects for further analysis.</p>\n"}, {"fullname": "ultk.effcomm.agent", "modulename": "ultk.effcomm.agent", "kind": "module", "doc": "<p>Classes for representing communicative agents, such as Senders and Receivers figuring in Lewis-Skyrms signaling games, literal and pragmatic agents in the Rational Speech Act framework, etc.</p>\n"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.__init__", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.language", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.language", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.shape", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.shape", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.weights", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.weights", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.normalized_weights", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.normalized_weights", "kind": "function", "doc": "<p>Return the normalized weights of a CommunicativeAgent so that each row vector represents a probability distribution.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.initialize_weights", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.initialize_weights", "kind": "function", "doc": "<p>Initialize the agent's weight matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>weights:</strong>  an np.ndarray representing the weights to initialize the agent with. By default None, and the agent's weights will be initialized uniformly.</li>\n<li><strong>initial:</strong>  {'ones', 'random'} a str reprsenting the initialization method to use. If 'ones' (default), initialize the weight matrix with <code>np.ones</code>. If 'random', initalize the weight matrix from <code>np.random.uniform</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">initial</span><span class=\"o\">=</span><span class=\"s1\">&#39;ones&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.referent_to_index", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.referent_to_index", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">referent</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.index_to_referent", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.index_to_referent", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.expression_to_index", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.expression_to_index", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">expression</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.index_to_expression", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.index_to_expression", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.strategy_to_indices", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.strategy_to_indices", "kind": "function", "doc": "<p>Maps communicative strategies to weights.</p>\n\n<p>Given a expression and referent, access the corresponding weight coordinate.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>strategy:</strong>  a dict of the form {\"referent\": Referent, \"expression\": expression} representing an instance of communicative behavior, which we may call a communicative strategy for this agent.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">strategy</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.sample_strategy", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.sample_strategy", "kind": "function", "doc": "<p>Sample a communicative strategy (e.g., a word for Speaker's intended referent, or interpretation for Listener's heard word) by uniformly sampling from a row vector of the agent's weight matrix specified by the index.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>index:</strong>  the integer index representing a row of the weight matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the integer index of the agent's choice</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.CommunicativeAgent.to_language", "modulename": "ultk.effcomm.agent", "qualname": "CommunicativeAgent.to_language", "kind": "function", "doc": "<p>Get a language from the agent, representing its current (possibly learned) communicative behavior.</p>\n\n<h6 id=\"this-function-uses\">This function uses:</h6>\n\n<blockquote>\n  <ol>\n  <li>the agent's weight matrix,</li>\n  <li>the set of expression forms, and</li>\n  <li>the set of referents</li>\n  </ol>\n</blockquote>\n\n<p>from the language the agent was initialized with to generate a new language accurately reflecting the new expression meanings, e.g. how the agent interprets expressions as meaning zero or more referents.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>threshold:</strong>  a float in [0,1] representing the cutoff for determining if a meaning (referent) can be communicated by a expression. Because weights are not initialized to 0, it is a good idea to set nonzero values as the threshold.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a Language corresponding to the form-meaning mapping defined by the communicative agent's weights.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;complexity&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"s1\">&#39;accuracy&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">}</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.Speaker", "modulename": "ultk.effcomm.agent", "qualname": "Speaker", "kind": "class", "doc": "<p></p>\n", "bases": "CommunicativeAgent"}, {"fullname": "ultk.effcomm.agent.Speaker.__init__", "modulename": "ultk.effcomm.agent", "qualname": "Speaker.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.effcomm.agent.Speaker.S", "modulename": "ultk.effcomm.agent", "qualname": "Speaker.S", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.effcomm.agent.Speaker.normalized_weights", "modulename": "ultk.effcomm.agent", "qualname": "Speaker.normalized_weights", "kind": "function", "doc": "<p>Get the normalized weights of a Speaker.</p>\n\n<p>Each row vector represents a conditional probability distribution over expressions, P(e | m).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.Listener", "modulename": "ultk.effcomm.agent", "qualname": "Listener", "kind": "class", "doc": "<p></p>\n", "bases": "CommunicativeAgent"}, {"fullname": "ultk.effcomm.agent.Listener.__init__", "modulename": "ultk.effcomm.agent", "qualname": "Listener.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.effcomm.agent.Listener.R", "modulename": "ultk.effcomm.agent", "qualname": "Listener.R", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.effcomm.agent.Listener.normalized_weights", "modulename": "ultk.effcomm.agent", "qualname": "Listener.normalized_weights", "kind": "function", "doc": "<p>Normalize the weights of a Listener so that each row vector for the heard expression e represents a conditional probability distribution over referents P(m | e).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.agent.LiteralSpeaker", "modulename": "ultk.effcomm.agent", "qualname": "LiteralSpeaker", "kind": "class", "doc": "<p>A literal speaker chooses utterances without any reasoning about other agents. The literal speaker's conditional probability distribution P(e|m) is uniform over all expressions that can be used to communicate a particular meaning. This is in contrast to a pragmatic speaker, whose conditional distribution is not uniform in this way, but instead biased towards choosing expressions that are less likely to be misinterpreted by some listener.</p>\n", "bases": "Speaker"}, {"fullname": "ultk.effcomm.agent.LiteralSpeaker.__init__", "modulename": "ultk.effcomm.agent", "qualname": "LiteralSpeaker.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.effcomm.agent.LiteralSpeaker.S", "modulename": "ultk.effcomm.agent", "qualname": "LiteralSpeaker.S", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.effcomm.agent.LiteralListener", "modulename": "ultk.effcomm.agent", "qualname": "LiteralListener", "kind": "class", "doc": "<p>A naive literal listener interprets utterances without any reasoning about other agents. Its conditional probability distribution P(m|e) for guessing meanings is uniform over all meanings that can be denoted by the particular expression heard. This is in contrast to a pragmatic listener, whose conditional distribution is biased to guess meanings that a pragmatic speaker most likely intended.</p>\n", "bases": "Listener"}, {"fullname": "ultk.effcomm.agent.LiteralListener.__init__", "modulename": "ultk.effcomm.agent", "qualname": "LiteralListener.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.effcomm.agent.LiteralListener.R", "modulename": "ultk.effcomm.agent", "qualname": "LiteralListener.R", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.effcomm.agent.PragmaticSpeaker", "modulename": "ultk.effcomm.agent", "qualname": "PragmaticSpeaker", "kind": "class", "doc": "<p>A pragmatic speaker chooses utterances based on how a listener would interpret them. A pragmatic speaker may be initialized with any kind of listener, e.g. literal or pragmatic -- meaning the recursive reasoning can be modeled up to arbitrary depth.</p>\n", "bases": "Speaker"}, {"fullname": "ultk.effcomm.agent.PragmaticSpeaker.__init__", "modulename": "ultk.effcomm.agent", "qualname": "PragmaticSpeaker.__init__", "kind": "function", "doc": "<p>Initialize the |M|-by-|E| matrix, S, corresponding to the pragmatic speaker's conditional probability distribution over expressions given meanings.</p>\n\n<p>The pragmatic speaker chooses expressions to communicate their intended meaning according to:</p>\n\n<p>$P(e | m) \\propto \\exp(t * u(e,m))$</p>\n\n<p>where $t \\in [0,1]$ is a temperature parameter and utility $u$ is defined</p>\n\n<p>$u(e , m) := \\log(P_{\\text{Listener}}(m | e))$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the language with |M| meanings and |E| expressions defining the size of S.</li>\n<li><strong>listener:</strong>  a communicative agent storing a matrix R representing the conditional distribution over expressions given meanings.</li>\n<li><strong>temperature:</strong>  a float \\in [0,1], representing how `optimally rational' the pragmatic speaker is; 1.0 is chosen when no particular assumptions about rationality are made.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">listener</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Listener</span>,</span><span class=\"param\">\t<span class=\"n\">temperature</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.effcomm.agent.PragmaticSpeaker.S", "modulename": "ultk.effcomm.agent", "qualname": "PragmaticSpeaker.S", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.effcomm.agent.PragmaticListener", "modulename": "ultk.effcomm.agent", "qualname": "PragmaticListener", "kind": "class", "doc": "<p>A pragmatic listener interprets utterances based on their expectations about a pragmatic speaker's decisions. A pragmatic listener may be initialized with any kind of speaker, e.g. literal or pragmatic -- meaning the recursive reasoning can be modeled up to arbitrary depth.</p>\n", "bases": "Listener"}, {"fullname": "ultk.effcomm.agent.PragmaticListener.__init__", "modulename": "ultk.effcomm.agent", "qualname": "PragmaticListener.__init__", "kind": "function", "doc": "<p>Initialize the |E|-by-|M| matrix, R, corresponding to the pragmatic listener's conditional probability distribution over meanings given expressions.</p>\n\n<p>The pragmatic listener chooses meanings as their best guesses of the expression they heard according to:</p>\n\n<p>$P(m | e) \\propto P_{\\text{PragmaticSpeaker}}(e | m)$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the language with |M| meanings and |E| expressions defining the size of R.</li>\n<li><strong>speaker:</strong>  a communicative agent storing a matrix S representing the  conditional distribution over expressions given meanings.</li>\n<li><strong>prior:</strong>  a diagonal matrix of size |M|-by-|M| representing the communicative need probabilities for meanings.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">speaker</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Speaker</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.effcomm.agent.PragmaticListener.R", "modulename": "ultk.effcomm.agent", "qualname": "PragmaticListener.R", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.effcomm.analysis", "modulename": "ultk.effcomm.analysis", "kind": "module", "doc": "<p>Functions for analyzing and formatting the results of the simplicity/informativeness trade-off.</p>\n"}, {"fullname": "ultk.effcomm.analysis.get_dataframe", "modulename": "ultk.effcomm.analysis", "qualname": "get_dataframe", "kind": "function", "doc": "<p>Get a pandas DataFrame for a list of languages containing efficient communication data.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  the list of languages to map into a dataframe.</li>\n<li><strong>columns:</strong>  the list of keys to a language's <code>data</code> dictionary attribute, which will comprise the columns of the resulting dataframe. By default will use all items of each language's <code>data</code> dictionary.</li>\n<li><strong>subset:</strong>  the columns to subset for duplicates</li>\n<li><strong>duplicates:</strong>  {\"drop\", \"count\", \"leave\"} whether to drop, count, or do nothing with duplicates. By default is set to \"leave\" which will leave duplicates in the dataframe.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>data: a pandas DataFrame with rows as individual languages, with the columns specifying their data.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">subset</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;complexity&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;comm_cost&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">duplicates</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;leave&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.analysis.pearson_analysis", "modulename": "ultk.effcomm.analysis", "qualname": "pearson_analysis", "kind": "function", "doc": "<p>Measures pearson correlation coefficient for naturalness with a property.</p>\n\n<p>Use nonparametric bootstrap for confidence intervals.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  a DataFrame representing the pool of measured languages</li>\n<li><strong>predictor:</strong>  a string representing the column to measure pearson r with</li>\n<li><strong>property:</strong>  a string representing a column to measure pearson r with the predictor column</li>\n<li><strong>num_bootstrap_samples:</strong>  how many samples to bootstrap from the original data</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the pearson correlation coefficient for the predictor and the property, and bootstrapped confidence intervals for this coefficient, e.g.</p>\n\n<pre><code>{\n\"rho\": (a float between -1 and 1),\n\"confidence_intervals\": (a pandas Dataframe with the columns [\n    'bootstrap_sample_percent', 'low', 'high'\n])\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">predictor</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"nb\">property</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">num_bootstrap_samples</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.analysis.trade_off_means", "modulename": "ultk.effcomm.analysis", "qualname": "trade_off_means", "kind": "function", "doc": "<p>Get a dataframe with the mean tradeoff data.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>name:</strong>  a str representing the subset of the population to observe mean properties for, e.g. \"natural\" or \"population\".</li>\n<li><strong>df:</strong>  a pandas DataFrame containing data of a language population to take the means of.</li>\n<li><strong>prperties:</strong>  the properties to take means of, corresponding to columns of <code>df</code>.</li>\n</ul>\n\n<p>Examples:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">natural_means</span> <span class=\"o\">=</span> <span class=\"n\">trade_off_means</span><span class=\"p\">(</span><span class=\"s2\">&quot;natural_means&quot;</span><span class=\"p\">,</span> <span class=\"n\">natural_data</span><span class=\"p\">,</span> <span class=\"n\">properties</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">population_means</span> <span class=\"o\">=</span> <span class=\"n\">trade_off_means</span><span class=\"p\">(</span><span class=\"s2\">&quot;population_means&quot;</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">properties</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">means_df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">concat</span><span class=\"p\">([</span><span class=\"n\">natural_means</span><span class=\"p\">,</span> <span class=\"n\">dlsav_means</span><span class=\"p\">,</span> <span class=\"n\">population_means</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">set_index</span><span class=\"p\">(</span><span class=\"s2\">&quot;name&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">means_df</span>\n<span class=\"go\">                    simplicity  complexity  informativity  optimality</span>\n<span class=\"go\">    name</span>\n<span class=\"go\">    natural_means       0.772222     16.4000       0.746296    0.952280</span>\n<span class=\"go\">    population_means    0.681068     22.9631       0.525118    0.832010</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.analysis.trade_off_ttest", "modulename": "ultk.effcomm.analysis", "qualname": "trade_off_ttest", "kind": "function", "doc": "<p>Get a dataframe with a single-samples t-test results for a subpopulation against the full population.</p>\n\n<p>This is useful if we want to compare the optimality of natural languages to the full population of languages in an experiment. Because the property of 'being a natural language' is categorical, we use a single-samples T test.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sub_population:</strong>  a pandas DataFrame representing a subset of the population to take ttests against the full language population for <code>properties</code>.</li>\n<li><strong>population_means:</strong>  a dict containing properties as keys and the mean value of the full language population for that property.</li>\n<li><strong>properties:</strong>  a list of strings corresponding to columns of the <code>sub_population</code> DataFrame and keys of the <code>population_means</code> dict.</li>\n</ul>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">trade_off_ttest</span><span class=\"p\">(</span><span class=\"n\">natural_data</span><span class=\"p\">,</span> <span class=\"n\">population_means</span><span class=\"p\">,</span> <span class=\"n\">properties</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">df</span>\n<span class=\"go\">                        simplicity  complexity  informativity  optimality</span>\n<span class=\"go\">    stat</span>\n<span class=\"go\">    t-statistic          4.101937   -4.101937       3.126855    4.031027</span>\n<span class=\"go\">    Two-sided p-value    0.014830    0.014830       0.035292    0.015720</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sub_population</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">population_means</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.informativity", "modulename": "ultk.effcomm.informativity", "kind": "module", "doc": "<p>Functions for measuring informativity in efficient communication analyses of languages.</p>\n"}, {"fullname": "ultk.effcomm.informativity.build_utility_matrix", "modulename": "ultk.effcomm.informativity", "qualname": "build_utility_matrix", "kind": "function", "doc": "<p>Construct the square matrix specifying the utility function defined for pairs of meanings, used for computing communicative success.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">universe</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.informativity.indicator_utility", "modulename": "ultk.effcomm.informativity", "qualname": "indicator_utility", "kind": "function", "doc": "<p>Indicator utility function, i.e. delta.  Returns 1.0 iff ref1 equals ref2.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ref1</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span>,</span><span class=\"param\">\t<span class=\"n\">ref2</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.informativity.informativity", "modulename": "ultk.effcomm.informativity", "qualname": "informativity", "kind": "function", "doc": "<p>The informativity of a language is identified with the successful communication between a speaker and a listener.</p>\n\n<p>This function is a wrapper for <code>communicative_success</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the language to compute informativity of.</li>\n<li><strong>prior:</strong>  a probability distribution representing communicative need (frequency) for Referents.</li>\n<li><strong>utility:</strong>  a function representing the usefulness of listener guesses about speaker Referents, e.g. Referent similarity. To reward only exact recovery of meanings, use the indicator function (default).</li>\n<li><strong>kind:</strong>  {\"literal, pragmatic\"} Whether to measure informativity using literal or pragmatic agents, as canonically described in the Rational Speech Act framework. The default is \"literal\".</li>\n</ul>\n\n<p><em>Concepts</em>:\n    The speaker can be thought of as a conditional distribution over expressions given meanings. The listener is likewise a conditional distribution over meanings given expressions. The communicative need, or cognitive source, is a prior probability over meanings representing how frequently agents need to use certain meanings in communication. The utility function represents the similarity, or appropriateness, of the listener's guess m' about the speaker's intended meaning m.</p>\n\n<p><em>Formula</em>:\n    The informativity of a language $L$ with meaning space $M$ is defined:</p>\n\n<p>$I(L) := \\sum_{m \\in M} p(m) \\sum_{i \\in L} p(i|m) \\sum_{\\hat{m} \\in i} p(\\hat{m}|i) \\cdot u(m, \\hat{m})$</p>\n\n<p><em>Bounds</em>:\n    A perfectly informative (=1.0) language can be constructed with a exactly one expression for each meaning.</p>\n\n<pre><code>For u() = indicator(), every language has nonzero informativity because a language must contain at least one expression, and an expression must contain at least one meaning.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">indicator_utility</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">agent_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;literal&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.informativity.communicative_success", "modulename": "ultk.effcomm.informativity", "qualname": "communicative_success", "kind": "function", "doc": "<p>Helper function to compute the literal informativity of a language.</p>\n\n<p>$I(L) = \\sum_{m, \\hat{m}} P(m, \\hat{m}) \\cdot u(m, \\hat{m})$</p>\n\n<p>$ = \\sum_{m \\in M} p(m) \\sum_{i \\in L} p(i|m) \\sum_{\\hat{m} \\in i} p(\\hat{m} |i) \\cdot u(m, m')$</p>\n\n<p>$ = \\sum \\text{diag}(p)SR \\odot U $</p>\n\n<p>For more details, see <a href=\"https://github.com/CLMBRs/altk/blob/main/docs/vectorized_informativity.pdf\">docs/vectorized_informativity</a>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>speaker:</strong>  a literal or pragmatic speaker, containing a matrix S for P(e | m)</li>\n<li><strong>listener:</strong>  a literal or pragmatic listener, containing a matrix R for P(m | e)</li>\n<li><strong>prior:</strong>  p(m), distribution over meanings representing communicative need</li>\n<li><strong>utility:</strong>  a function u(m, m') representing similarity of meanings, or pair-wise usefulness of listener guesses about speaker meanings.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">speaker</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Speaker</span>,</span><span class=\"param\">\t<span class=\"n\">listener</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Listener</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization", "modulename": "ultk.effcomm.optimization", "kind": "module", "doc": "<p>Classes and functions for generating languages that optimize the simplicity/informativeness trade-off, e.g. via an iterative evolutionary algorithm.</p>\n"}, {"fullname": "ultk.effcomm.optimization.Mutation", "modulename": "ultk.effcomm.optimization", "qualname": "Mutation", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.Mutation.precondition", "modulename": "ultk.effcomm.optimization", "qualname": "Mutation.precondition", "kind": "function", "doc": "<p>Whether a mutation is allowed to apply to a language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.Mutation.mutate", "modulename": "ultk.effcomm.optimization", "qualname": "Mutation.mutate", "kind": "function", "doc": "<p>Mutate the language, possibly using a list of expressions.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.RemoveExpression", "modulename": "ultk.effcomm.optimization", "qualname": "RemoveExpression", "kind": "class", "doc": "<p></p>\n", "bases": "Mutation"}, {"fullname": "ultk.effcomm.optimization.RemoveExpression.precondition", "modulename": "ultk.effcomm.optimization", "qualname": "RemoveExpression.precondition", "kind": "function", "doc": "<p>Whether a mutation is allowed to apply to a language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.RemoveExpression.mutate", "modulename": "ultk.effcomm.optimization", "qualname": "RemoveExpression.mutate", "kind": "function", "doc": "<p>Mutate the language, possibly using a list of expressions.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.AddExpression", "modulename": "ultk.effcomm.optimization", "qualname": "AddExpression", "kind": "class", "doc": "<p></p>\n", "bases": "Mutation"}, {"fullname": "ultk.effcomm.optimization.AddExpression.precondition", "modulename": "ultk.effcomm.optimization", "qualname": "AddExpression.precondition", "kind": "function", "doc": "<p>Whether a mutation is allowed to apply to a language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.AddExpression.mutate", "modulename": "ultk.effcomm.optimization", "qualname": "AddExpression.mutate", "kind": "function", "doc": "<p>Mutate the language, possibly using a list of expressions.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer", "kind": "class", "doc": "<p>Class for approximating the Pareto frontier of languages optimizing the simplicity/informativity trade-off.</p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.__init__", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.__init__", "kind": "function", "doc": "<p>Initialize the evolutionary algorithm configurations.</p>\n\n<p>The measures of complexity and informativity, the expressions, and the mutations are all specific to the particular semantic domain.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>objectives:</strong>  a dict of the two objectives to optimize for, e.g. simplicity and informativeness, of the form, e.g.\n{\n    \"complexity\": comp_measure,\n    \"comm_cost\": lambda l: 1 - inf_measure(l)\n}</li>\n<li><strong>expressions:</strong>     a list of expressions from which to apply mutations to languages.</li>\n<li><strong>sample_size:</strong>   the size of the population at every generation.</li>\n<li><strong>max_muatations:</strong>    between 1 and this number of mutations will be applied to a subset of the population at the end of each generation.</li>\n<li><strong>generations:</strong>   how many iterations to run the evolutionary algorithm for.</li>\n<li><strong>lang_size:</strong>     between 1 and this number of expressions comprise a language.</li>\n<li><strong>mutations:</strong>  (optional) a list of Mutation objects, defaults to add/remove expression</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">objectives</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">max_mutations</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">generations</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\tmutations: tuple[typing.Type[ultk.effcomm.optimization.Mutation], ...] = (&lt;class &#x27;ultk.effcomm.optimization.AddExpression&#x27;&gt;, &lt;class &#x27;ultk.effcomm.optimization.RemoveExpression&#x27;&gt;)</span>)</span>"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.objectives", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.objectives", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.expressions", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.expressions", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.mutations", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.mutations", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.sample_size", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.sample_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.max_mutations", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.max_mutations", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.generations", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.generations", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.lang_size", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.lang_size", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.dominating_languages", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.dominating_languages", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.explored_languages", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.explored_languages", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.fit", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.fit", "kind": "function", "doc": "<p>Computes the Pareto frontier, a set languages which cannot be both more simple and more informative.</p>\n\n<p>Uses pygmo's nondominated_front method for computing a population's best solutions to a multi-objective optimization problem.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>seed_population:</strong>  a list of languages representing the population at generation 0 of the algorithm.</li>\n<li><strong>explore:</strong>  a float in [0,1] representing how much to optimize for fitness\n(optimality wrt pareto front of complexity and comm_cost), and how much to randomly explore.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the estimated optimization solutions, as well as points explored along the way; of the form</p>\n\n<pre><code>{\n\"dominating_languages\": list of languages as estimated solutions,\n\"explored_languages\": list of all the languages explored during the evolutionary algorithm,\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">seed_population</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">explore</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.sample_mutated", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.sample_mutated", "kind": "function", "doc": "<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  dominating languages of a generation</li>\n<li><strong>amount:</strong>  sample_size.</li>\n<li><strong>expressions:</strong>  the list of expressions</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list of updated languages</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.EvolutionaryOptimizer.mutate", "modulename": "ultk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.mutate", "kind": "function", "doc": "<p>Randomly selects a mutation that is allowed to apply and applies it to a language.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the Language to mutate</li>\n<li><strong>expressions:</strong>  the list of all possible expressions.\nSome mutations need access to this list, so it is part of the mutation api.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the mutated Language</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.optimization.sample_parents", "modulename": "ultk.effcomm.optimization", "qualname": "sample_parents", "kind": "function", "doc": "<p>Use the explore parameter to explore possibly suboptimal areas of the language space.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dominating_languages:</strong>  a list of the languages with current best fitness with respect to the objectives.</li>\n<li><strong>explored_languages:</strong>  a list of all languages encountered during the evolutionary algorithm.</li>\n<li><strong>explore:</strong>  a float in <code>[0,1]</code> specifying how much to explore possibly suboptimal languages.\nIf set to 0, <code>parent_languages</code> is just <code>dominating_languages</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the languages to serve as the next generation (after possible mutations)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dominating_languages</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">explored_languages</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">explore</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.sampling", "modulename": "ultk.effcomm.sampling", "kind": "module", "doc": "<p>Functions for sampling expressions into languages.</p>\n"}, {"fullname": "ultk.effcomm.sampling.get_hypothetical_variants", "modulename": "ultk.effcomm.sampling", "qualname": "get_hypothetical_variants", "kind": "function", "doc": "<p>For each system (parameterized by a language or else a speaker), generate <code>num</code> hypothetical variants by permuting the signals that the system assigns to states.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  a list of languages to permute, by constructing LiteralSpeakers and permuting their weights.</li>\n<li><strong>speakers:</strong>  a list of speakers of a language, whose weights can be directly permuted. Should be used instead of <code>languages</code> if possible, because it can be more finegrained (every language can be associated with multiple speakers).</li>\n<li><strong>total:</strong>  the total number of hypothetical variants to obtain. Should be greater than the number of languages.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>hypothetical_variants: a list of type either Language or np.ndarray depending on whether <code>languages</code> or <code>speakers</code> was passed, representing hypothetical variants of the systems passed. If <code>speakers</code> was passed, a list of speakers is returned.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">speakers</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Speaker</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.tradeoff", "modulename": "ultk.effcomm.tradeoff", "kind": "module", "doc": "<p>Functions for constructing an efficient communication analysis by measuring the simplicity/informativeness trade-off languages and formatting results as a dataframe or a plot.</p>\n"}, {"fullname": "ultk.effcomm.tradeoff.dominates", "modulename": "ultk.effcomm.tradeoff", "qualname": "dominates", "kind": "function", "doc": "<p>Determine whether p1 dominates p2,\ni.e. whether for every i p1[i] &lt;= p2[i]\nand for some i p1[i] &lt; p2[i].</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p1:</strong>  a point</li>\n<li><strong>p2:</strong>  another point</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>whether or not p1 dominates p2</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.tradeoff.non_dominated_2d", "modulename": "ultk.effcomm.tradeoff", "qualname": "non_dominated_2d", "kind": "function", "doc": "<p>Return the non-dominated (Pareto) front of a list of 2-D points, using Kung's algorithm.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points:</strong>  A list of 2-D points</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a list, the indices of <code>points</code> for which no other point is as good on all dimensions\n  and better on at least one</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.tradeoff.pareto_optimal_languages", "modulename": "ultk.effcomm.tradeoff", "qualname": "pareto_optimal_languages", "kind": "function", "doc": "<p>Use non_dominated_2d to compute the Pareto languages.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">objectives</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">unique</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.tradeoff.pareto_min_distances", "modulename": "ultk.effcomm.tradeoff", "qualname": "pareto_min_distances", "kind": "function", "doc": "<p>Measure the Pareto optimality of each language by measuring its Euclidean closeness to the frontier. The frontier is a line (list of points) interpolated from the pareto points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points:</strong>  the list of all language (x, y) pairs, where x and y are usually communicative cost and complexity.</li>\n<li><strong>pareto_points:</strong>  the list of all dominant language (x, y) pairs to constitute the Pareto frontier. The points should have been measured by pygmo's non_dominated_front_2d function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>min_distances: an array of shape <code>len(points)</code> Euclidean distances for each language to the closest point on the Pareto frontier.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">pareto_points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.tradeoff.interpolate_data", "modulename": "ultk.effcomm.tradeoff", "qualname": "interpolate_data", "kind": "function", "doc": "<p>Interpolate the points yielded by the pareto optimal languages into a continuous (though not necessarily smooth) curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points:</strong>  an list of (comm_cost, complexity) pairs of size [dominating_languages], a possibly non-smooth set of solutions to the trade-off.</li>\n<li><strong>min_cost:</strong>  the minimum communicative cost value possible to interpolate from.</li>\n<li><strong>max_cost:</strong>  the maximum communicative cost value possible to interpolate from. A natural assumption is to let complexity=0.0 if max_cost=1.0, which will result in a Pareto curve that spans the entire 2d space, and consequently the plot with x and y limits both ranging [0.0, 1.0].</li>\n<li><strong>num:</strong>  the number of x-axis points (cost) to interpolate. Controls smoothness of curve.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>interpolated_points: an array of size <code>(num, num)</code></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">min_cost</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_cost</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">num</span><span class=\"o\">=</span><span class=\"mi\">5000</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.effcomm.tradeoff.tradeoff", "modulename": "ultk.effcomm.tradeoff", "qualname": "tradeoff", "kind": "function", "doc": "<p>Builds a final efficient communication analysis by measuring a list of languages, updating their internal data, and returning the results.</p>\n\n<p>This function measures possibly many graded or categorical properties of each language, but minimally the properties of commmunicative cost and complexity. These two measures fully define the results of an efficiency analysis, in the sense they define the optimal solutions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  A list representing the pool of all languages to be measured for an efficient communication analysis.</li>\n<li><strong>x:</strong>  the first pressure to measure, e.g. communicative cost.</li>\n<li><strong>y:</strong>  the second pressure to measure, e.g. cognitive complexity.</li>\n<li><strong>frontier:</strong>  a list of (comm_cost, complexity) points representing a Pareto frontier to measure optimality w.r.t.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dictionary of the population and the pareto front, of the form</p>\n\n<pre><code>{\n    \"languages\": the list of languages, with their internal efficient communication data updated,\n\n    \"dominating_languages\": the list of the languages dominating the population w.r.t. comm_cost and complexity. If no `frontier` is none, this can be considered the Pareto frontier.\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;comm_cost&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;complexity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">frontier</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language", "modulename": "ultk.language", "kind": "module", "doc": "<p>Classes for modeling (natural or hypothetical) languagese.</p>\n\n<p>At the current stage of development, ULTK focuses on supporting abstractions to model the mapping between expressions and meanings of a language. So far, we leave almost everything besides this basic mapping (morphosyntax, phonology, phonetic inventories, among other features of human languages) to future work.</p>\n\n<p>The <code>ultk.language.language</code> submodule contains classes for constructing a language, which can contain one or more expressions. </p>\n\n<p>The <code>ultk.language.semantics</code> submodule contains classes for defining a universe (meaning space) of referents (denotations) and meanings (categories).</p>\n"}, {"fullname": "ultk.language.grammar", "modulename": "ultk.language.grammar", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ultk.language.grammar.Rule", "modulename": "ultk.language.grammar", "qualname": "Rule", "kind": "class", "doc": "<p>Basic class for a grammar rule.  Grammar rules in ULTK correspond\nto functions.  One can think of a grammar as generating complex functions from\nmore basic ones.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>lhs:</strong>  left-hand side of the rule (can be anything)\nconceptually, the output type of a function</li>\n<li><strong>rhs:</strong>  right-hand side; assumed to be an iterable\nconceptually, a list of types of inputs</li>\n<li><strong>func:</strong>  a callable, the function to be computed when a node with this rule is executed</li>\n<li><strong>name:</strong>  name of the function</li>\n<li><strong>weight:</strong>  a relative weight to assign to this rule\nwhen added to a grammar, all rules with the same LHS will be weighted together</li>\n</ul>\n"}, {"fullname": "ultk.language.grammar.Rule.__init__", "modulename": "ultk.language.grammar", "qualname": "Rule.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">Rule</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">weight</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span>)</span>"}, {"fullname": "ultk.language.grammar.Rule.name", "modulename": "ultk.language.grammar", "qualname": "Rule.name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "ultk.language.grammar.Rule.lhs", "modulename": "ultk.language.grammar", "qualname": "Rule.lhs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Any"}, {"fullname": "ultk.language.grammar.Rule.rhs", "modulename": "ultk.language.grammar", "qualname": "Rule.rhs", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Sequence | None"}, {"fullname": "ultk.language.grammar.Rule.func", "modulename": "ultk.language.grammar", "qualname": "Rule.func", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Rule.weight", "modulename": "ultk.language.grammar", "qualname": "Rule.weight", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "1.0"}, {"fullname": "ultk.language.grammar.Rule.is_terminal", "modulename": "ultk.language.grammar", "qualname": "Rule.is_terminal", "kind": "function", "doc": "<p>Whether this is a terminal rule.  In our framework, this means that RHS is empty,\ni.e. there are no arguments to the function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Rule.from_callable", "modulename": "ultk.language.grammar", "qualname": "Rule.from_callable", "kind": "function", "doc": "<p>Create a Rule from the type-annotations of a function.</p>\n\n<p>For example, given the following method definition:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span> <span class=\"nf\">_and</span><span class=\"p\">(</span><span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"nb\">bool</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"k\">return</span> <span class=\"n\">p1</span> <span class=\"ow\">and</span> <span class=\"n\">p2</span>\n</code></pre>\n</div>\n\n<p>This class method will return the Rule:</p>\n\n<pre><code>Rule(name=\"_and\", lhs=bool, rhs=(bool, bool), func=_and)\n</code></pre>\n\n<p>There are two special kwargs that can be used in the function definition:</p>\n\n<ul>\n<li><code>weight</code>: a float, which will be used as the weight of the rule</li>\n<li><code>name</code>: a string, which will be used as the name of the rule, if you want it to be different than the name of the method</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">Rule</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.GrammaticalExpression", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression", "kind": "class", "doc": "<p>A GrammaticalExpression has been built up from a Grammar by applying a sequence of Rules.\nCrucially, it is _callable_, using the functions corresponding to each rule.</p>\n\n<p>A GrammaticalExpression, when called, takes in a Referent.  Because of this, a Meaning can\nbe generated by specifying a Universe (which contains Referents).</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>rule_name:</strong>  name of the top-most function</li>\n<li><strong>func:</strong>  the function</li>\n<li><strong>children:</strong>  child expressions (possibly empty)</li>\n</ul>\n", "bases": "ultk.language.language.Expression[~T]"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.__init__", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">form</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">meaning</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">Meaning</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"o\">=</span><span class=\"n\">FrozenDict</span><span class=\"p\">({}),</span> <span class=\"n\">universe</span><span class=\"o\">=</span><span class=\"n\">Universe</span><span class=\"p\">(</span><span class=\"n\">referents</span><span class=\"o\">=</span><span class=\"p\">(),</span> <span class=\"n\">prior</span><span class=\"o\">=</span><span class=\"p\">()))</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">rule_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">children</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">term_expression</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span>)</span>"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.rule_name", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.rule_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.func", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.func", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Callable"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.children", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.children", "kind": "variable", "doc": "<p></p>\n", "annotation": ": tuple | None"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.term_expression", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.term_expression", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.yield_string", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.yield_string", "kind": "function", "doc": "<p>Get the 'yield' string of this term, i.e. the concatenation\nof the leaf nodes.</p>\n\n<p>This is useful for thinking of a <code>Grammar</code> as generating derivation trees for\nan underlying CFG.  This method will then generate the strings generated by\nthe corresponding CFG.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.evaluate", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.evaluate", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">universe</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.add_child", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.add_child", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">child</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.to_dict", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.to_dict", "kind": "function", "doc": "<p>Return a dictionary representation of the expression.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.count_atoms", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.count_atoms", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.GrammaticalExpression.from_dict", "modulename": "ultk.language.grammar", "qualname": "GrammaticalExpression.from_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">the_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">grammar</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">Grammar</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.UniquenessArgs", "modulename": "ultk.language.grammar", "qualname": "UniquenessArgs", "kind": "class", "doc": "<p>Arguments for specifying uniqueness of GrammaticalExpressions in a Grammar.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>unique_expressions:</strong>  a dictionary in which to store unique Expressions</li>\n<li><strong>key:</strong>  a function used to evaluate uniqueness</li>\n<li><strong>compare_func:</strong>  a comparison function, used to decide which Expression to add to the dict\nnew Expressions will be added as values to <code>unique_dict</code> only if they are minimal\namong those sharing the same key (by <code>unique_key</code>) according to this func</li>\n</ul>\n", "bases": "typing.TypedDict"}, {"fullname": "ultk.language.grammar.UniquenessArgs.unique_expressions", "modulename": "ultk.language.grammar", "qualname": "UniquenessArgs.unique_expressions", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict[typing.Any, dict[typing.Any, ultk.language.grammar.GrammaticalExpression]]"}, {"fullname": "ultk.language.grammar.UniquenessArgs.key", "modulename": "ultk.language.grammar", "qualname": "UniquenessArgs.key", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Callable[[ultk.language.grammar.GrammaticalExpression], Any]"}, {"fullname": "ultk.language.grammar.UniquenessArgs.compare_func", "modulename": "ultk.language.grammar", "qualname": "UniquenessArgs.compare_func", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Callable[[ultk.language.grammar.GrammaticalExpression, ultk.language.grammar.GrammaticalExpression], bool]"}, {"fullname": "ultk.language.grammar.Grammar", "modulename": "ultk.language.grammar", "qualname": "Grammar", "kind": "class", "doc": "<p>At its core, a Grammar is a set of Rules with methods for generating GrammaticalExpressions.</p>\n"}, {"fullname": "ultk.language.grammar.Grammar.__init__", "modulename": "ultk.language.grammar", "qualname": "Grammar.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span>)</span>"}, {"fullname": "ultk.language.grammar.Grammar.add_rule", "modulename": "ultk.language.grammar", "qualname": "Grammar.add_rule", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rule</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">Rule</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.parse", "modulename": "ultk.language.grammar", "qualname": "Grammar.parse", "kind": "function", "doc": "<p>Parse a string representation of an expression of a grammar.\nNote that this is not a general-purpose parsing algorithm.  We assume that the strings are of the form\n    parent_name(child1_name, ..., childn_name)\nwhere parent_name is the name of a rule of this grammar that has a length-n RHS, and that\nchildi_name is the name of a rule for each child i.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>expression:</strong>  string in the above format</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the corresponding GrammaticalExpression</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">expression</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">opener</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;(&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">closer</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;)&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">delimiter</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;,&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.generate", "modulename": "ultk.language.grammar", "qualname": "Grammar.generate", "kind": "function", "doc": "<p>Generate an expression from a given lhs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.enumerate", "modulename": "ultk.language.grammar", "qualname": "Grammar.enumerate", "kind": "function", "doc": "<p>Enumerate all expressions from the grammar up to a given depth from a given LHS.\nThis method also can update a specified dictionary to store only _unique_ expressions, with\na user-specified criterion of uniqueness.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>depth:</strong>  how deep the trees should be</li>\n<li><strong>lhs:</strong>  left hand side to start from; defaults to the grammar's start symbol</li>\n<li><strong>uniqueness_args:</strong>  a dictionary specifying the parameters for uniqueness:\nunique_dict: a dictionary in which to store unique Expressions\nkey: a function used to evaluate uniqueness\ncompare_func: a comparison function, used to decide which Expression to add to the dict\n    new Expressions will be added as values to <code>unique_dict</code> only if they are _minimal_\n    among those sharing the same key (by <code>unique_key</code>) according to this func</li>\n</ul>\n\n<h6 id=\"yields\">Yields:</h6>\n\n<blockquote>\n  <p>all GrammaticalExpressions up to depth</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">depth</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">8</span>,</span><span class=\"param\">\t<span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">uniqueness_args</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">UniquenessArgs</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.enumerate_at_depth", "modulename": "ultk.language.grammar", "qualname": "Grammar.enumerate_at_depth", "kind": "function", "doc": "<p>Enumerate GrammaticalExpressions for this Grammar _at_ a fixed depth.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">depth</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">uniqueness_args</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">UniquenessArgs</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cache</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.get_unique_expressions", "modulename": "ultk.language.grammar", "qualname": "Grammar.get_unique_expressions", "kind": "function", "doc": "<p>Get all unique GrammaticalExpressions, up to a certain depth, with a user-specified criterion\nof uniqueness, and a specified comparison function for determining which Expression to save when there's a clash.\nThis can be used, for instance, to measure the minimum description length of some\nMeanings, by using expression.evaluate(), which produces a Meaning for an Expression, as the\nkey for determining uniqueness, and length of the expression as comparison.</p>\n\n<p>This is a wrapper around <code>enumerate</code>, but which produces the dictionary of key->Expression entries\nand returns it.  (<code>enumerate</code> is a generator with side effects).</p>\n\n<p>For Args, see the docstring for <code>enumerate</code>.</p>\n\n<p>Note: if you additionally want to store _all_ expressions, and not just the unique ones, you should\ndirectly use <code>enumerate</code>.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dictionary of {key: GrammaticalExpression}, where the keys are generated by <code>unique_key</code>\n  The GrammticalExpression which is the value will be the one that is minimum among\n  <code>compare_func</code> amongst all Expressions up to <code>depth</code> which share the same key</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">depth</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">unique_key</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">],</span> <span class=\"n\">Any</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">compare_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">,</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"n\">inf</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.get_all_rules", "modulename": "ultk.language.grammar", "qualname": "Grammar.get_all_rules", "kind": "function", "doc": "<p>Get all rules as a list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">Rule</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.from_yaml", "modulename": "ultk.language.grammar", "qualname": "Grammar.from_yaml", "kind": "function", "doc": "<p>Read a grammar specified in a simple YAML format.</p>\n\n<p>Expected format:</p>\n\n<pre><code>start: bool\nrules:\n- lhs: bool\n  rhs:\n  - bool\n  - bool\n  name: \"and\"\n  func: \"lambda p1, p2 : p1 and p2\"\n- lhs: bool\n  rhs:\n  - bool\n  - bool\n  name: \"or\"\n  func: \"lambda p1, p2 : p1 or p2\"\n</code></pre>\n\n<p>Note that for each fule, the value for <code>func</code> will be passed to\n<code>eval</code>, so be careful!</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>filename:</strong>  file containing a grammar in the above format</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.grammar.Grammar.from_module", "modulename": "ultk.language.grammar", "qualname": "Grammar.from_module", "kind": "function", "doc": "<p>Read a grammar from a module.</p>\n\n<p>The module should have a list of type-annotated method definitions, each of which will correspond to one Rule in the new Grammar.\nSee the docstring for <code>Rule.from_callable</code> for more information on how that step works.</p>\n\n<p>The start symbol of the grammar can either be specified by <code>start = XXX</code> somewhere in the module,\nor will default to the LHS of the first rule in the module (aka the return type annotation of the first method definition).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>module_name:</strong>  name of the module</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">module_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">Grammar</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language", "modulename": "ultk.language.language", "kind": "module", "doc": "<p>Classes for modeling languages as form-meaning mappings, most important among them the Language and Expression classes.</p>\n\n<h6 id=\"example-usage\">Example usage:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">ultk.language.language</span> <span class=\"kn\">import</span> <span class=\"n\">Expression</span><span class=\"p\">,</span> <span class=\"n\">Language</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># assuming the meaning `a_few_meaning` has already been constructed</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># define the expression</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a_few</span> <span class=\"o\">=</span> <span class=\"n\">NumeralExpression</span><span class=\"p\">(</span><span class=\"n\">form</span><span class=\"o\">=</span><span class=\"s2\">&quot;a few&quot;</span><span class=\"p\">,</span> <span class=\"n\">meaning</span><span class=\"o\">=</span><span class=\"n\">a_few_meaning</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># define a very small language</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">lang_1</span> <span class=\"o\">=</span> <span class=\"n\">Language</span><span class=\"p\">([</span><span class=\"n\">a_few</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># or a slightly larger one with synonymy</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">lang_2</span> <span class=\"o\">=</span> <span class=\"n\">Language</span><span class=\"p\">([</span><span class=\"n\">a_few</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n</code></pre>\n  </div>\n</blockquote>\n"}, {"fullname": "ultk.language.language.Expression", "modulename": "ultk.language.language", "qualname": "Expression", "kind": "class", "doc": "<p>Minimally contains a form and a meaning.</p>\n", "bases": "typing.Generic[~T]"}, {"fullname": "ultk.language.language.Expression.__init__", "modulename": "ultk.language.language", "qualname": "Expression.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">form</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">meaning</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">Meaning</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"o\">=</span><span class=\"n\">FrozenDict</span><span class=\"p\">({}),</span> <span class=\"n\">universe</span><span class=\"o\">=</span><span class=\"n\">Universe</span><span class=\"p\">(</span><span class=\"n\">referents</span><span class=\"o\">=</span><span class=\"p\">(),</span> <span class=\"n\">prior</span><span class=\"o\">=</span><span class=\"p\">()))</span></span>)</span>"}, {"fullname": "ultk.language.language.Expression.form", "modulename": "ultk.language.language", "qualname": "Expression.form", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "ultk.language.language.Expression.meaning", "modulename": "ultk.language.language", "qualname": "Expression.meaning", "kind": "variable", "doc": "<p></p>\n", "annotation": ": ultk.language.semantics.Meaning[~T]", "default_value": "Meaning(mapping=FrozenDict({}), universe=Universe(referents=(), prior=()))"}, {"fullname": "ultk.language.language.Expression.can_express", "modulename": "ultk.language.language", "qualname": "Expression.can_express", "kind": "function", "doc": "<p>Return True if the expression can express the input single meaning point and false otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">referent</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language.Expression.to_dict", "modulename": "ultk.language.language", "qualname": "Expression.to_dict", "kind": "function", "doc": "<p>Return a dictionary representation of the expression.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language.Language", "modulename": "ultk.language.language", "qualname": "Language", "kind": "class", "doc": "<p>Minimally contains Expression objects.</p>\n"}, {"fullname": "ultk.language.language.Language.__init__", "modulename": "ultk.language.language", "qualname": "Language.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.language.language.Language.universe", "modulename": "ultk.language.language", "qualname": "Language.universe", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.language.language.Language.expressions", "modulename": "ultk.language.language", "qualname": "Language.expressions", "kind": "variable", "doc": "<p></p>\n", "annotation": ": frozenset[ultk.language.language.Expression]"}, {"fullname": "ultk.language.language.Language.add_expression", "modulename": "ultk.language.language", "qualname": "Language.add_expression", "kind": "function", "doc": "<p>Add an expression to the list of expressions in a language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language.Language.is_natural", "modulename": "ultk.language.language", "qualname": "Language.is_natural", "kind": "function", "doc": "<p>Whether a language represents a human natural language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language.Language.degree_property", "modulename": "ultk.language.language", "qualname": "Language.degree_property", "kind": "function", "doc": "<p>Count what percentage of expressions in a language have a given property.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"nb\">property</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language.Language.binary_matrix", "modulename": "ultk.language.language", "qualname": "Language.binary_matrix", "kind": "function", "doc": "<p>Get a binary matrix of shape <code>(num_meanings, num_expressions)</code>\nspecifying which expressions can express which meanings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language.Language.as_dict_with_properties", "modulename": "ultk.language.language", "qualname": "Language.as_dict_with_properties", "kind": "function", "doc": "<p>Return a dictionary representation of the language, including additional properties as keyword arguments.</p>\n\n<p>This is used in some examples to serialize the language to outputs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.language.aggregate_expression_complexity", "modulename": "ultk.language.language", "qualname": "aggregate_expression_complexity", "kind": "function", "doc": "<p>Aggregate complexities for individual <code>Expression</code>s into a complexity for a <code>Language</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the Language to measure</li>\n<li><strong>expression_complexity_func:</strong>  the function that returns the complexity of an individual expression</li>\n<li><strong>aggregator:</strong>  (optional, default = sum) the function that aggregates individual complexities</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a float, the complexity of a language</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">expression_complexity_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">aggregator</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">sum</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling", "modulename": "ultk.language.sampling", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ultk.language.sampling.powerset", "modulename": "ultk.language.sampling", "qualname": "powerset", "kind": "function", "doc": "<p>Enumerate all _non-empty_ subsets of an iterable up to a given maximum size, e.g.:\npowerset([1,2,3]) --> (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)</p>\n\n<p>lightly adapted from itertools Recipes at\n<a href=\"https://docs.python.org/3/library/itertools.html#itertools-recipes\">https://docs.python.org/3/library/itertools.html#itertools-recipes</a></p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>iterable:</strong>  elements from which to form subsets</li>\n<li><strong>max_size:</strong>  largest subsets (inclusive) to return</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>iterator over all subsets from size 1 to <code>max_size</code> of elements from <code>iterable</code></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iterable</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span>, </span><span class=\"param\"><span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.all_meanings", "modulename": "ultk.language.sampling", "qualname": "all_meanings", "kind": "function", "doc": "<p>Generate all Meanings (sets of Referents) from a given Universe.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">universe</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.all_expressions", "modulename": "ultk.language.sampling", "qualname": "all_expressions", "kind": "function", "doc": "<p>Generate Expressions from an iterable of Meanings.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">meanings</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.all_languages", "modulename": "ultk.language.sampling", "qualname": "all_languages", "kind": "function", "doc": "<p>Generate all Languages (sets of Expressions) from a given set of Expressions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>expressions:</strong>  iterable of all possible expressions</li>\n<li><strong>language_class:</strong>  the type of language to generate</li>\n<li><strong>max_size:</strong>  largest size for a language; if None, all subsets of expressions will be used</li>\n</ul>\n\n<h6 id=\"yields\">Yields:</h6>\n\n<blockquote>\n  <p>Languages with subsets of Expressions from <code>expressions</code></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\tlanguage_class: Type[ultk.language.language.Language] = &lt;class &#x27;ultk.language.language.Language&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.upto_comb", "modulename": "ultk.language.sampling", "qualname": "upto_comb", "kind": "function", "doc": "<p>Return the number of ways of choosing _up to max_k_ items from\nn items without repetition.  Just an iterator of math.comb for n from\n1 to max_k.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">num</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">max_k</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.random_languages", "modulename": "ultk.language.sampling", "qualname": "random_languages", "kind": "function", "doc": "<p>Generate unique Languages by randomly sampling subsets of Expressions, either in a uniform or stratified way.\nIf there are fewer than <code>sample_size</code> possible Languages up to size <code>max_size</code>,\nthis method will just return all languages up to that size (and so the sample may\nbe smaller than <code>sample_size</code>).</p>\n\n<p>Some use cases:</p>\n\n<p>With <code>sample_size=None</code>, get all languages.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">random_languages</span><span class=\"p\">(</span><span class=\"n\">expressions</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>With <code>sample_size</code> and uniform sampling, get random languages:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">random_languages</span><span class=\"p\">(</span><span class=\"n\">expressions</span><span class=\"p\">,</span> <span class=\"n\">sample_size</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Stratified sampling, with and without a <code>max_size</code>:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">random_languages</span><span class=\"p\">(</span><span class=\"n\">expressions</span><span class=\"p\">,</span> <span class=\"n\">sample_size</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">sampling_strategy</span><span class=\"o\">=</span><span class=\"s2\">&quot;stratified&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">random_languages</span><span class=\"p\">(</span><span class=\"n\">expressions</span><span class=\"p\">,</span> <span class=\"n\">sample_size</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">sampling_strategy</span><span class=\"o\">=</span><span class=\"s2\">&quot;stratified&quot;</span><span class=\"p\">,</span> <span class=\"n\">max_size</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>expressions:</strong>  all possible expressions</li>\n<li><strong>sampling_strategy:</strong>  how to sample subsets of expressions\nuniform: for every expression, choose whether or not to include it in a given language\nstratified: first sample a size for a Language, then choose that many random Expressions\n    (i) this has the effect of \"upsampling\" from smaller Language sizes\n    (ii) this can be used with <code>max_size</code> to only generate Languages up to a given number of expressions</li>\n<li><strong>sample_size:</strong>  how many languages to return\nif None, will return all languages up to <code>max_size</code></li>\n<li><strong>language_class:</strong>  type of Language</li>\n<li><strong>max_size:</strong>  largest possible Language to generate\nif None, will be the length of <code>expressions</code>\nNB: this argument has no effect when <code>sampling_strategy</code> is \"uniform\"</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a list of randomly sampled Languages</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">sampling_strategy</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;uniform&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\tlanguage_class: Type[ultk.language.language.Language] = &lt;class &#x27;ultk.language.language.Language&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.generate_languages", "modulename": "ultk.language.sampling", "qualname": "generate_languages", "kind": "function", "doc": "<p>Generate languages by randomly sampling vocabularies as bags of expressions.</p>\n\n<p>A predicate (binary-valued property) of expressions may be supplied, which can be used to adjust the composition of vocabularies (e.g., by the percent of expressions satisfying the predicate).</p>\n\n<p>If sample size &lt;= nCr, then take a random sample_size set of combinations. Otherwise, to prevent repeat languages, treat nCr as the sample size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>expressions:</strong>  a list of the possible expressions to sample from.</li>\n<li><strong>lang_size:</strong>  the maximum (or exact) number of expressions in each language.</li>\n<li><strong>sample_size:</strong>  the number of languages to generate.</li>\n<li><strong>criterion:</strong>  the predicate, (e.g. semantic universal) by which to split the expressions into those satisfying and those not, and then sample languages with degrees of naturalness based on the percentage from those satisfying. Must apply at the expression level. By default is a trivial criterion, so that all expressions are 'quasi-natural'.</li>\n<li><strong>fixed_wordcount:</strong>  whether to vary the language size from 1 to lang_size.</li>\n<li><strong>verbose:</strong>  How detailed the progress of sampling should be, printed to stdout.</li>\n<li><strong>dummy_name:</strong>  the default name to give to each sampled language, e.g. <code>sampled_lang_42</code>. These should not collide with any actual natural language names if the efficient communication experiment does use natural language data.</li>\n<li><strong>id_start:</strong>  an integer representing the number of languages already generated in an experiment. Languages sampled will be named according to this number. For example, if id_start is 0, the first language sampled will be named <code>sampled_lang_0</code>. Note that the largest id does not necessarily track the actual size of languages saved for the experiment, but it does track how many languages have been generated.</li>\n<li><strong>exact_sample:</strong>  a boolean representing whether to sample until the exact sample size is filled. If True, the resulting pool of languages may not be unique.</li>\n<li><strong>verbose:</strong>  a boolean representing how verbose output should be during sampling.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict representing the generated pool of languages and the updated id_start, of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Turn the knob on a universal property for modals</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">expressions</span> <span class=\"o\">=</span> <span class=\"n\">load_expressions</span><span class=\"p\">(</span><span class=\"n\">expressions_file</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">universal_property</span> <span class=\"o\">=</span> <span class=\"n\">iff</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">generate_languages</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>   <span class=\"n\">ModalLanguage</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">expressions</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">lang_size</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">sample_size</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">universal_property</span><span class=\"p\">,</span>\n<span class=\"go\">...)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">languages</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">&quot;languages&quot;</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">id_start</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">&quot;id_start&quot;</span><span class=\"p\">]</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">criterion</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_wordcount</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">exact_sample</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.sample_lang_size", "modulename": "ultk.language.sampling", "qualname": "sample_lang_size", "kind": "function", "doc": "<p>Get a sample of languages each of exactly lang_size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language_class:</strong>  a subclass of ultk.Language</li>\n<li><strong>expressions:</strong>  a list of Expressions to sample from</li>\n<li><strong>lang_size:</strong>  int representing the maximum language size to sample</li>\n<li><strong>sample_size:</strong>  int representing the number of total languages to return</li>\n<li><strong>id_start:</strong>  an int representing the number of languages already generated in an experiment.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict containing the randomly sampled languages and the updated id_start, of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_id&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.sample_quasi_natural", "modulename": "ultk.language.sampling", "qualname": "sample_quasi_natural", "kind": "function", "doc": "<p>Turn the knob on degree quasi-naturalness for a sample of languages, either by enumerating or randomly sampling unique subsets of all possible combinations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>natural_terms:</strong>  expressions satisfying some criteria of quasi-naturalness, e.g, a semantic universal.</li>\n<li><strong>unnatural_terms:</strong>  expressions not satisfying the criteria.</li>\n<li><strong>lang_size:</strong>  the exact number of expressions a language must have.</li>\n<li><strong>sample_size:</strong>  how many languages to sample.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict containing the randomly sampled quasi-natural languages and the updated id_start, of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">natural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.rename_id", "modulename": "ultk.language.sampling", "qualname": "rename_id", "kind": "function", "doc": "<p>Updates a string of form <code>sampled_lang_X</code> with a new id for X.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.enumerate_all_languages", "modulename": "ultk.language.sampling", "qualname": "enumerate_all_languages", "kind": "function", "doc": "<p>When the sample size requested is greater than the size of all possible languages, just enumerate all the possible languages.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language_class:</strong>  the kind of Language to construct</li>\n<li><strong>id_start:</strong>  a number to start counting from for assigning names with numerical ids to languages.</li>\n<li><strong>natural_indices:</strong>  the indices of quasi-natural languages already seen</li>\n<li><strong>num_natural:</strong>  the number of quasi-natural languages to sample</li>\n<li><strong>natural_terms:</strong>  the list of quasi-natural terms to sample from</li>\n<li><strong>unnatural_indices:</strong>  the indices of non-quasi-natural languages already seen</li>\n<li><strong>num_unnatural:</strong>  the number of non-quasi-natural languages to sample; 0 by default</li>\n<li><strong>unnatural_terms:</strong>  the list of non-quasi-natural terms to sample from; empty by default.</li>\n<li><strong>dummy_name:</strong>  the format of the string to name each language constructed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict containing a set of languages and the updated id_start,  of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">natural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">natural_indices</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">num_natural</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_indices</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">num_unnatural</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.sampling.random_combination_vocabulary", "modulename": "ultk.language.sampling", "qualname": "random_combination_vocabulary", "kind": "function", "doc": "<p>Get a single vocabulary for a specific language size by choosing a random combination of natural and unnatural terms.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>seen:</strong>  the list of language indices already seen</li>\n<li><strong>num_natural:</strong>  int</li>\n<li><strong>natural_terms:</strong>  list[Expression]</li>\n<li><strong>num_unnatural:</strong>  int=0</li>\n<li><strong>unnatural_terms:</strong>  list[Expression]=[]</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>languages: the extended list of input languages.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">seen</span><span class=\"p\">:</span> <span class=\"nb\">set</span>,</span><span class=\"param\">\t<span class=\"n\">num_natural</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">natural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">num_unnatural</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.semantics", "modulename": "ultk.language.semantics", "kind": "module", "doc": "<p>Classes for modeling the meanings of a language.</p>\n\n<p>Meanings are modeled as things which map linguistic forms to objects of reference. The linguistic forms and objects of reference can in principle be very detailed, and future work may elaborate the meaning classes and implement a Form class.</p>\n\n<p>In efficient communication analyses, simplicity and informativeness can be measured as properties of semantic aspects of a language. E.g., a meaning is simple if it is easy to represent, or to compress into some code; a meaning is informative if it is easy for a listener to recover a speaker's intended literal meaning.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">ultk.language.semantics</span> <span class=\"kn\">import</span> <span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"n\">Meaning</span><span class=\"p\">,</span> <span class=\"n\">Universe</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">ultk.language.language</span> <span class=\"kn\">import</span> <span class=\"n\">Expression</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># construct the meaning space for numerals</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">numerals_universe</span> <span class=\"o\">=</span> <span class=\"n\">NumeralUniverse</span><span class=\"p\">(</span><span class=\"n\">referents</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">NumeralReferent</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># construct a list of referents for the expression &#39;a few&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a_few_refs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">NumeralReferent</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a_few_meaning</span> <span class=\"o\">=</span> <span class=\"n\">NumeralMeaning</span><span class=\"p\">(</span><span class=\"n\">referents</span><span class=\"o\">=</span><span class=\"n\">a_few_refs</span><span class=\"p\">,</span> <span class=\"n\">universe</span><span class=\"o\">=</span><span class=\"n\">numerals_universe</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># define the expression</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a_few</span> <span class=\"o\">=</span> <span class=\"n\">NumeralExpression</span><span class=\"p\">(</span><span class=\"n\">form</span><span class=\"o\">=</span><span class=\"s2\">&quot;a few&quot;</span><span class=\"p\">,</span> <span class=\"n\">meaning</span><span class=\"o\">=</span><span class=\"n\">a_few_meaning</span><span class=\"p\">)</span>\n</code></pre>\n  </div>\n</blockquote>\n"}, {"fullname": "ultk.language.semantics.Referent", "modulename": "ultk.language.semantics", "qualname": "Referent", "kind": "class", "doc": "<p>A referent is some object in the universe for a language.</p>\n\n<p>Conceptually, a Referent can be any kind of object.  This functions like a generic python object that is _immutable_ after initialization.\nAt initialization, properties can be specified either by passing a dictionary or by keyword arguments.</p>\n"}, {"fullname": "ultk.language.semantics.Referent.__init__", "modulename": "ultk.language.semantics", "qualname": "Referent.__init__", "kind": "function", "doc": "<p>Initialize a referent.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>name:</strong>  a string representing the name of the referent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "ultk.language.semantics.Referent.name", "modulename": "ultk.language.semantics", "qualname": "Referent.name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.language.semantics.Universe", "modulename": "ultk.language.semantics", "qualname": "Universe", "kind": "class", "doc": "<p>The universe is the collection of possible referent objects for a meaning.</p>\n"}, {"fullname": "ultk.language.semantics.Universe.__init__", "modulename": "ultk.language.semantics", "qualname": "Universe.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">referents</span>, </span><span class=\"param\"><span class=\"n\">prior</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "ultk.language.semantics.Universe.referents", "modulename": "ultk.language.semantics", "qualname": "Universe.referents", "kind": "variable", "doc": "<p></p>\n", "annotation": ": tuple[ultk.language.semantics.Referent, ...]"}, {"fullname": "ultk.language.semantics.Universe.prior", "modulename": "ultk.language.semantics", "qualname": "Universe.prior", "kind": "variable", "doc": "<p></p>\n", "annotation": ": tuple[float, ...]"}, {"fullname": "ultk.language.semantics.Universe.size", "modulename": "ultk.language.semantics", "qualname": "Universe.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "ultk.language.semantics.Universe.prior_numpy", "modulename": "ultk.language.semantics", "qualname": "Universe.prior_numpy", "kind": "variable", "doc": "<p></p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "ultk.language.semantics.Universe.from_dataframe", "modulename": "ultk.language.semantics", "qualname": "Universe.from_dataframe", "kind": "function", "doc": "<p>Build a Universe from a DataFrame.\nIt's assumed that each row specifies one Referent, and each column will be a property\nof that Referent.  We assume that <code>name</code> is one of the columns of the DataFrame.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li>a DataFrame representing the meaning space of interest, assumed to have a column <code>name</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.semantics.Universe.from_csv", "modulename": "ultk.language.semantics", "qualname": "Universe.from_csv", "kind": "function", "doc": "<p>Build a Universe from a CSV file.  This is a small wrapper around\n<code>Universe.from_dataframe</code>, so see that documentation for more information.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.language.semantics.Meaning", "modulename": "ultk.language.semantics", "qualname": "Meaning", "kind": "class", "doc": "<p>A meaning maps Referents to any type of object.</p>\n\n<p>For instance, sentence meanings are often modeled as sets of points (e.g. possible worlds).\nThese correspond to mappings from points (i.e. Referents) to truth values, corresponding to the characteristic function of a set.\nBut, in general, meanings can have a different output type for, e.g. sub-sentential meanings..</p>\n\n<h6 id=\"properties\">Properties:</h6>\n\n<blockquote>\n  <p>mapping: a <code>FrozenDict</code> with <code>Referent</code> keys, but arbitrary type <code>T</code> as values.</p>\n  \n  <p>universe: a Universe object.  The <code>Referent</code>s in the keys of <code>mapping</code> are expected to be exactly those in <code>universe</code>.</p>\n  \n  <p>_dist: a mapping representing a probability distribution over referents to associate with the meaning. By default, will be assumed to be uniform over the \"true-like\" <code>Referent</code>s in <code>mapping</code> (see <code>.dist</code>).</p>\n</blockquote>\n", "bases": "typing.Generic[~T]"}, {"fullname": "ultk.language.semantics.Meaning.__init__", "modulename": "ultk.language.semantics", "qualname": "Meaning.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mapping</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">util</span><span class=\"o\">.</span><span class=\"n\">frozendict</span><span class=\"o\">.</span><span class=\"n\">FrozenDict</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">universe</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span></span>)</span>"}, {"fullname": "ultk.language.semantics.Meaning.mapping", "modulename": "ultk.language.semantics", "qualname": "Meaning.mapping", "kind": "variable", "doc": "<p></p>\n", "annotation": ": ultk.util.frozendict.FrozenDict[ultk.language.semantics.Referent, ~T]"}, {"fullname": "ultk.language.semantics.Meaning.universe", "modulename": "ultk.language.semantics", "qualname": "Meaning.universe", "kind": "variable", "doc": "<p></p>\n", "annotation": ": ultk.language.semantics.Universe"}, {"fullname": "ultk.language.semantics.Meaning.dist", "modulename": "ultk.language.semantics", "qualname": "Meaning.dist", "kind": "variable", "doc": "<p></p>\n", "annotation": ": ultk.util.frozendict.FrozenDict[ultk.language.semantics.Referent, float]"}, {"fullname": "ultk.language.semantics.Meaning.is_uniformly_false", "modulename": "ultk.language.semantics", "qualname": "Meaning.is_uniformly_false", "kind": "function", "doc": "<p>Return True if all referents in the meaning are mapped to False (or coercible to False).In the case where the meaning type is boolean, this corresponds to the characteristic function of the empty set.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.util", "modulename": "ultk.util", "kind": "module", "doc": "<p>Various utility classes and helper functions for the ULTK package.</p>\n\n<p>Submodules:</p>\n\n<ul>\n<li><code>frozendict</code>: An immutable dictionary, so that various mappings (e.g. <code>Meaning</code>s) can be hashed, serialized, etc.</li>\n<li><code>io</code>: some basic input/output functions.</li>\n</ul>\n"}, {"fullname": "ultk.util.frozendict", "modulename": "ultk.util.frozendict", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ultk.util.frozendict.FrozenDict", "modulename": "ultk.util.frozendict", "qualname": "FrozenDict", "kind": "class", "doc": "<p></p>\n", "bases": "dict[~K, ~V], typing.Generic[~K, ~V], yaml.YAMLObject"}, {"fullname": "ultk.util.frozendict.FrozenDict.clear", "modulename": "ultk.util.frozendict", "qualname": "FrozenDict.clear", "kind": "function", "doc": "<p>D.clear() -> None.  Remove all items from D.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.frozendict.FrozenDict.pop", "modulename": "ultk.util.frozendict", "qualname": "FrozenDict.pop", "kind": "function", "doc": "<p>D.pop(k[,d]) -> v, remove specified key and return the corresponding value.</p>\n\n<p>If the key is not found, return the default if given; otherwise,\nraise a KeyError.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">default</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.frozendict.FrozenDict.popitem", "modulename": "ultk.util.frozendict", "qualname": "FrozenDict.popitem", "kind": "function", "doc": "<p>Remove and return a (key, value) pair as a 2-tuple.</p>\n\n<p>Pairs are returned in LIFO (last-in, first-out) order.\nRaises KeyError if the dict is empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.frozendict.FrozenDict.setdefault", "modulename": "ultk.util.frozendict", "qualname": "FrozenDict.setdefault", "kind": "function", "doc": "<p>Insert key with a value of default if key is not in the dictionary.</p>\n\n<p>Return the value for key if key is in the dictionary, else default.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">default</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.frozendict.FrozenDict.update", "modulename": "ultk.util.frozendict", "qualname": "FrozenDict.update", "kind": "function", "doc": "<p>D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.io", "modulename": "ultk.util.io", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "ultk.util.io.write_expressions", "modulename": "ultk.util.io", "qualname": "write_expressions", "kind": "function", "doc": "<p>Write expressions to a YAML file.</p>\n\n<p>This is particularly useful for writing GrammaticalExpressions, which have a <code>func</code> field that can't be serialized. This function uses <code>to_dict</code> to determine which properties of the Expression to write.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>expressions:</strong>  the expressions to write</li>\n<li><strong>filename:</strong>  the file to write to</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.io.read_grammatical_expressions", "modulename": "ultk.util.io", "qualname": "read_grammatical_expressions", "kind": "function", "doc": "<p>Read grammatical expressions from a YAML file.</p>\n\n<p>Optionally re-parse and (re-)evaluate the expressions using the provided grammar and universe.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>filename:</strong>  the file to read</li>\n<li><strong>grammar:</strong>  the grammar to use for parsing (and for re-populating the <code>.func</code> attribute of each GrammaticalExpression)</li>\n<li><strong>re_parse:</strong>  whether to re-parse the expressions</li>\n<li><strong>universe:</strong>  the universe to use for evaluation</li>\n<li><strong>return_by_meaning:</strong>  whether to return a dictionary mapping meanings to expressions or not</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a list of GrammaticalExpressions and a dictionary mapping meanings to expressions (empty if <code>return_by_meaning</code> is False)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">grammar</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">Grammar</span>,</span><span class=\"param\">\t<span class=\"n\">re_parse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">universe</span><span class=\"p\">:</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">return_by_meaning</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">],</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span><span class=\"p\">,</span> <span class=\"n\">ultk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">grammar</span><span class=\"o\">.</span><span class=\"n\">GrammaticalExpression</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.io.write_pickle", "modulename": "ultk.util.io", "qualname": "write_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fn</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ultk.util.io.read_pickle", "modulename": "ultk.util.io", "qualname": "read_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fn</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();